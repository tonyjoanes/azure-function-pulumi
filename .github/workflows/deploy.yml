name: Deploy Azure Function with Pulumi

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod

env:
  DOTNET_VERSION: '8.0.x'
  AZURE_FUNCTIONAPP_PACKAGE_PATH: './src'

jobs:
  # Build and Test Job
  build-and-test:
    runs-on: ubuntu-latest
    name: Build and Test Azure Function
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
    
    - name: Restore Function dependencies
      run: dotnet restore ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}/HelloWorldFunction.csproj
    
    - name: Build Function
      run: dotnet build ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}/HelloWorldFunction.csproj --configuration Release --no-restore
    
    - name: Test Function (if tests exist)
      run: |
        if [ -f "${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}/HelloWorldFunction.Tests.csproj" ]; then
          dotnet test ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}/HelloWorldFunction.Tests.csproj --no-build --verbosity normal
        else
          echo "No tests found, skipping test step"
        fi
    
    - name: Publish Function
      run: dotnet publish ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}/HelloWorldFunction.csproj --configuration Release --output ./publish
    
    - name: Upload Function Artifact
      uses: actions/upload-artifact@v4
      with:
        name: azure-function-app
        path: ./publish

  # Infrastructure Deployment Job
  deploy-infrastructure:
    runs-on: ubuntu-latest
    name: Deploy Infrastructure with Pulumi
    needs: build-and-test
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    
    outputs:
      function-app-name: ${{ steps.pulumi.outputs.functionAppName }}
      resource-group-name: ${{ steps.pulumi.outputs.resourceGroupName }}
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
    
    - name: Restore Infrastructure dependencies
      run: dotnet restore infrastructure/Infrastructure.csproj
    
    - name: Build Infrastructure
      run: dotnet build infrastructure/Infrastructure.csproj --configuration Release --no-restore
    
    - name: Install Pulumi CLI
      uses: pulumi/actions@v4
    
    - name: Configure Pulumi Stack
      run: |
        cd infrastructure
        STACK_NAME="${{ github.event.inputs.environment || 'dev' }}"
        pulumi stack select $STACK_NAME || pulumi stack init $STACK_NAME
      env:
        PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
        ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
        ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
        ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}
        ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
    
    - name: Configure Azure CLI
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Deploy Infrastructure
      id: pulumi
      run: |
        cd infrastructure
        pulumi stack select ${{ github.event.inputs.environment || 'dev' }} || pulumi stack init ${{ github.event.inputs.environment || 'dev' }}
        dotnet build Infrastructure.csproj --configuration Release
        pulumi up --yes --stack ${{ github.event.inputs.environment || 'dev' }}
        
        # Export outputs for next job with better error handling
        echo "Getting Pulumi outputs..."
        FUNCTION_APP_NAME=$(pulumi stack output functionAppName --stack ${{ github.event.inputs.environment || 'dev' }} 2>/dev/null || echo "")
        RESOURCE_GROUP_NAME=$(pulumi stack output resourceGroupName --stack ${{ github.event.inputs.environment || 'dev' }} 2>/dev/null || echo "")
        
        echo "Function App Name: $FUNCTION_APP_NAME"
        echo "Resource Group Name: $RESOURCE_GROUP_NAME"
        
        if [ -z "$FUNCTION_APP_NAME" ] || [ -z "$RESOURCE_GROUP_NAME" ]; then
          echo "ERROR: Failed to get Pulumi outputs"
          echo "Available outputs:"
          pulumi stack output --stack ${{ github.event.inputs.environment || 'dev' }}
          exit 1
        fi
        
        echo "functionAppName=$FUNCTION_APP_NAME" >> $GITHUB_OUTPUT
        echo "resourceGroupName=$RESOURCE_GROUP_NAME" >> $GITHUB_OUTPUT
      env:
        PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
        ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
        ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
        ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}
        ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}

  # Function Code Deployment Job
  deploy-function:
    runs-on: ubuntu-latest
    name: Deploy Function Code
    needs: [build-and-test, deploy-infrastructure]
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    
    steps:
    - name: Download Function Artifact
      uses: actions/download-artifact@v4
      with:
        name: azure-function-app
        path: ./publish
    
    - name: Configure Azure CLI
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Debug Resource Group Contents
      run: |
        echo "Listing all resources in resource group..."
        az resource list \
          --resource-group ${{ needs.deploy-infrastructure.outputs.resource-group-name }} \
          --query "[].{Name:name, Type:type, Kind:kind}" \
          --output table
    
    - name: Deploy Function Code to Azure
      run: |
        # Verify inputs
        echo "Resource Group: ${{ needs.deploy-infrastructure.outputs.resource-group-name }}"
        echo "Function App Name: ${{ needs.deploy-infrastructure.outputs.function-app-name }}"
        
        # Check if Function App exists
        echo "Verifying Function App exists..."
        az functionapp show \
          --resource-group ${{ needs.deploy-infrastructure.outputs.resource-group-name }} \
          --name ${{ needs.deploy-infrastructure.outputs.function-app-name }} \
          --query "name" --output tsv
        
        # List files in publish directory for debugging
        echo "Files in publish directory:"
        ls -la ./publish/
        
        # Verify critical files exist
        echo "Checking for critical function files:"
        echo "‚úì host.json: $(ls ./publish/host.json 2>/dev/null && echo "EXISTS" || echo "MISSING")"
        echo "‚úì worker.config.json: $(ls ./publish/worker.config.json 2>/dev/null && echo "EXISTS" || echo "MISSING")"
        echo "‚úì functions.metadata: $(ls ./publish/functions.metadata 2>/dev/null && echo "EXISTS" || echo "MISSING")"
        echo "‚úì HelloWorldFunction.dll: $(ls ./publish/HelloWorldFunction.dll 2>/dev/null && echo "EXISTS" || echo "MISSING")"
        
        # Create deployment package - using the method that worked manually
        echo "Creating deployment package..."
        cd ./publish
        # Package all files (excluding hidden files that might cause issues)
        zip -r ../function-app.zip * --exclude=".*"
        cd ..
        
        # Verify the zip file was created and show key contents
        echo "Zip file size: $(du -h function-app.zip | cut -f1)"
        echo "Key files in zip:"
        unzip -l function-app.zip | grep -E "(host\.json|worker\.config\.json|functions\.metadata|HelloWorldFunction\.dll)" || echo "Checking all files..."
        unzip -l function-app.zip | head -30
        
        # Deploy to Azure Function App with retries
        echo "Deploying function code..."
        for i in {1..3}; do
          if az functionapp deployment source config-zip \
            --resource-group ${{ needs.deploy-infrastructure.outputs.resource-group-name }} \
            --name ${{ needs.deploy-infrastructure.outputs.function-app-name }} \
            --src function-app.zip \
            --timeout 600; then
            echo "‚úÖ Deployment successful on attempt $i"
            break
          else
            echo "‚ùå Deployment failed on attempt $i"
            if [ $i -eq 3 ]; then
              echo "‚ùå All deployment attempts failed"
              exit 1
            fi
            sleep 30
          fi
        done
    
    - name: Verify Deployment
      run: |
        FUNCTION_URL="https://${{ needs.deploy-infrastructure.outputs.function-app-name }}.azurewebsites.net"
        echo "üöÄ Deployment Complete!"
        echo "Function App URL: $FUNCTION_URL"
        echo "Available Endpoints:"
        echo "  ‚Ä¢ Hello World: $FUNCTION_URL/api/HelloWorld"
        echo "  ‚Ä¢ Config Demo: $FUNCTION_URL/api/ConfigDemo"
        echo "  ‚Ä¢ Config Health: $FUNCTION_URL/api/ConfigHealth"
        echo "  ‚Ä¢ Environment Demo: $FUNCTION_URL/api/EnvironmentDemo"
        
        # Wait for function to be ready and test
        echo "‚è≥ Waiting for function app to fully start (60 seconds)..."
        sleep 60
        
        # Test multiple endpoints with retries
        echo "üß™ Testing endpoints..."
        
        # Test health endpoint with retries
        for i in {1..5}; do
          echo "üîç Testing health endpoint (attempt $i/5)..."
          if curl -f -s "$FUNCTION_URL/api/ConfigHealth" > /dev/null; then
            echo "‚úÖ Health endpoint responding!"
            HEALTH_RESPONSE=$(curl -s "$FUNCTION_URL/api/ConfigHealth")
            echo "Health check response: $HEALTH_RESPONSE"
            break
          else
            echo "‚è≥ Health endpoint not ready, waiting 15 seconds..."
            sleep 15
          fi
        done
        
        # Test hello world endpoint  
        echo "üîç Testing Hello World endpoint..."
        if curl -f -s "$FUNCTION_URL/api/HelloWorld" > /dev/null; then
          echo "‚úÖ Hello World endpoint responding!"
        else
          echo "‚ö†Ô∏è Hello World endpoint not responding yet"
        fi
        
        echo "üéØ Manual verification URLs:"
        echo "  üëâ $FUNCTION_URL/api/HelloWorld"
        echo "  üëâ $FUNCTION_URL/api/ConfigHealth"

  # Preview Job for Pull Requests
  preview-infrastructure:
    runs-on: ubuntu-latest
    name: Preview Infrastructure Changes
    needs: build-and-test
    if: github.event_name == 'pull_request'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
    
    - name: Restore Infrastructure dependencies
      run: dotnet restore infrastructure/Infrastructure.csproj
    
    - name: Build Infrastructure
      run: dotnet build infrastructure/Infrastructure.csproj --configuration Release --no-restore
    
    - name: Install Pulumi CLI
      uses: pulumi/actions@v4
    
    - name: Configure Pulumi Stack
      run: |
        cd infrastructure
        pulumi stack select dev || pulumi stack init dev
      env:
        PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
        ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
        ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
        ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}
        ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
    
    - name: Configure Azure CLI
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Preview Infrastructure Changes
      run: |
        cd infrastructure
        pulumi stack select dev || pulumi stack init dev
        dotnet build Infrastructure.csproj --configuration Release
        pulumi preview --stack dev
      env:
        PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
        ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
        ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}
        ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }} 